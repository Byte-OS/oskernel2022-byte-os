# 操作系统引导

## 1.操作系统引导

RISC-V芯片引导位置为`0x80000000`，由于可以使用`rustsbi`，因此在`0x80200000`处加入操作系统内核即可，无需再次编写`bootloader`.

## 2.sbi规范

## 3.操作系统入口函数

## 4.Rust build工具

```shell
cargo install cargo-binutils
rustup component add llvm-tools-preview
```

## 使用Rust定义全局变量

```rust
// CACHE_SIZE 是要定义的数组的大小
// 此时需要添加大小才能使用
// 在rust中 变量如果没有使用 可能并不会被有效编译
static mut CACHE: [u8;CACHE_SIZE] = [0;CACHE_SIZE];    

// rust初始化块内存
unsafe {
    core::slice::from_raw_parts_mut(bss_start_addr, bss_size).fill(0);
}
```

## Rust使用自定义的内存管理分配器(heap)

rust在如果使用no_std即使用core库且需要使用Ref Vec等功能需要自己实现#[global_allocator], 然后才能进行内存的分配

### Demo

```rust
use std::alloc::{GlobalAlloc, System, Layout};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        System.alloc(layout)
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout)
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;

fn main() {
    // This `Vec` will allocate memory through `GLOBAL` above
    let mut v = Vec::new();
    v.push(1);
}
```

### 使用buddy_system_allocator

```rust
use buddy_system_allocator::LockedHeap;

// 堆大小
const HEAP_SIZE: usize = 0x0001_0000;

// 堆空间
static mut HEAP: [u8;HEAP_SIZE] = [0;HEAP_SIZE];

// 堆内存分配器
#[global_allocator]
static HEAP_ALLOCATOR: LockedHeap<64> = LockedHeap::empty();


// 初始化堆内存分配器
pub fn init() {
    unsafe {
        HEAP_ALLOCATOR.lock().init(HEAP.as_ptr() as usize, HEAP_SIZE);
    }
}
```

## 设置输入

CR：Carriage Return，对应ASCII中转义字符\r，表示回车

LF：Linefeed，对应ASCII中转义字符\n，表示换行

CRLF：Carriage Return & Linefeed，\r\n，表示回车并换行

```rust
// 读入一个字符
pub fn read() -> char {
    console_getchar()
}

// 无回显输入
pub fn read_line(str: &mut String) {
    loop {
        let c = read();
        if c == '\n' {
            break;
        }
        str.push(c);
    }
}

// 有回显输入
pub fn read_line_display(str: &mut String) {
    loop {
        let c = read();
        console_putchar(c as u8);

        if c as u8 == 0x0D {
            console_putchar(0xa);
            break;
        }
        str.push(c);
    }
}

```

### utf8转换规则

> Unicode 与 UTF-8 编码有一个归纳的转换规则 ：
> Unicode Code    UTF-8 Code
>  0000～007F     0xxxxxxx
>  0080～07FF     110xxxxx 10xxxxxx
>  0800～FFFF     1110xxxx 10xxxxxx 10xxxxxx
> 10000～10FFFF   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

获取uf8字符后转unicode

```rust
if c as u8 >= 0b11000000 {
    // 获取到utf8字符 转unicode
    console_putchar(c as u8);
    let mut char_u32:u32 = c as u32;
    let times = if c as u8 <= 0b11100000 {
        char_u32 = char_u32 & 0x1f;
        1
    } else if c as u8 <= 0b11110000 {
        char_u32 = char_u32 & 0x0f;
        2
    } else {
        char_u32 = char_u32 & 0x07;
        3
    };
    

    for _ in 0..times {
        let c = read();
        console_putchar(c as u8);
        char_u32 = char_u32 << 6;
        char_u32 = char_u32 | ((c as u32) & 0x3f
    }
    
    str.push(char::from_u32(char_u32).unwrap());
    continue;
}
```

## 中断设置

rust中断设置，首先需要设置`stvec`，`stvec`设置中断入口的地址。