# 操作系统引导

## 1.操作系统引导

RISC-V芯片引导位置为`0x80000000`，由于可以使用`rustsbi`，因此在`0x80200000`处加入操作系统内核即可，无需再次编写`bootloader`.

## 2.sbi规范

## 3.操作系统入口函数

## 4.Rust build工具

```shell
cargo install cargo-binutils
rustup component add llvm-tools-preview
```

## 使用Rust定义全局变量

```rust
// CACHE_SIZE 是要定义的数组的大小
// 此时需要添加大小才能使用
// 在rust中 变量如果没有使用 可能并不会被有效编译
static mut CACHE: [u8;CACHE_SIZE] = [0;CACHE_SIZE];    

// rust初始化块内存
unsafe {
    core::slice::from_raw_parts_mut(bss_start_addr, bss_size).fill(0);
}
```

## Rust使用自定义的内存管理分配器(heap)

rust在如果使用no_std即使用core库且需要使用Ref Vec等功能需要自己实现#[global_allocator], 然后才能进行内存的分配

### Demo

```rust
use std::alloc::{GlobalAlloc, System, Layout};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        System.alloc(layout)
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout)
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;

fn main() {
    // This `Vec` will allocate memory through `GLOBAL` above
    let mut v = Vec::new();
    v.push(1);
}
```

### 使用buddy_system_allocator

```rust
use buddy_system_allocator::LockedHeap;

// 堆大小
const HEAP_SIZE: usize = 0x0001_0000;

// 堆空间
static mut HEAP: [u8;HEAP_SIZE] = [0;HEAP_SIZE];

// 堆内存分配器
#[global_allocator]
static HEAP_ALLOCATOR: LockedHeap<64> = LockedHeap::empty();


// 初始化堆内存分配器
pub fn init() {
    unsafe {
        HEAP_ALLOCATOR.lock().init(HEAP.as_ptr() as usize, HEAP_SIZE);
    }
}
```